

import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:math' as math;
import 'dart:typed_data';

import 'package:flutter/material.dart';
import 'package:dio/dio.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter_bluetooth_serial/flutter_bluetooth_serial.dart'
    as classic;
import 'package:permission_handler/permission_handler.dart';

/// Base URL for your cloud API. Replace with your own endpoint.
const kBaseUrl = 'https://api.your-cloud.com';
/// API key for authenticating against the cloud API. Replace with your own key.
const kApiKey = 'your_api_key';

/// Global Dio client configured with sensible defaults.
final _dio = Dio(
  BaseOptions(
    baseUrl: kBaseUrl,
    connectTimeout: const Duration(seconds: 10),
    receiveTimeout: const Duration(seconds: 10),
    headers: {
      'Authorization': 'Bearer $kApiKey',
    },
  ),
);

/// Represents a time series of points to plot on a chart.
class Series {
  final List<FlSpot> spots;
  Series(this.spots);

  /// Constructs a [Series] from a JSON array of pairs.
  factory Series.fromJson(dynamic data) {
    final iterable = _coerceIterable(data);
    final spots = <FlSpot>[];

    for (final entry in iterable) {
      final spot = _spotFromEntry(entry);
      if (spot != null) {
        spots.add(spot);
      }
    }

    return Series(spots);
  }

  static Iterable _coerceIterable(dynamic data) {
    if (data is Iterable) return data;
    if (data is String && data.trim().isNotEmpty) {
      final decoded = jsonDecode(data);
      if (decoded is Iterable) return decoded;
    }
    throw StateError('Series expects an iterable but received ${data.runtimeType}');
  }

  static FlSpot? _spotFromEntry(dynamic entry) {
    double? x;
    double? y;

    if (entry is List && entry.length >= 2) {
      x = _toDouble(entry[0]);
      y = _toDouble(entry[1]);
    } else if (entry is Map) {
      final map = entry.map((key, value) => MapEntry(key.toString(), value));
      x = _toDouble(map['x'] ?? map['timestamp'] ?? map['time'] ?? map['t']);
      y = _toDouble(map['y'] ?? map['value'] ?? map['emg_rms'] ?? map['rms']);
    }

    if (x == null || y == null) return null;
    return FlSpot(x, y);
  }

  static double? _toDouble(dynamic value) {
    if (value is num) return value.toDouble();
    if (value is String) return double.tryParse(value);
    return null;
  }
}

/// Represents a single history record returned by the cloud API.
class HistoryItem {
  final String id;
  final DateTime date;
  HistoryItem({required this.id, required this.date});
  factory HistoryItem.fromJson(dynamic json) {
    if (json is Map) {
      final map = json.map((key, value) => MapEntry(key.toString(), value));
      final id = (map['id'] ?? map['uuid'] ?? map['history_id'] ?? '').toString();
      final rawDate = map['date'] ?? map['created_at'] ?? map['timestamp'];
      final date = _parseDate(rawDate);
      if (id.isEmpty || date == null) {
        throw StateError('?¡æ?è§??æ­·å²ç´€?„ï?$map');
      }
      return HistoryItem(id: id, date: date);
    }

    if (json is List && json.length >= 2) {
      final id = json[0].toString();
      final date = _parseDate(json[1]);
      if (date == null) {
        throw StateError('?¡æ?è§??æ­·å²ç´€?„ï?$json');
      }
      return HistoryItem(id: id, date: date);
    }

    throw StateError('Unsupported history item format: ${json.runtimeType}');
  }

  static DateTime? _parseDate(dynamic value) {
    if (value is DateTime) return value;
    if (value is num) {
      // Assume seconds if value is reasonably small, otherwise milliseconds.
      final millis = value > 1e12 ? value.toInt() : (value * 1000).toInt();
      return DateTime.fromMillisecondsSinceEpoch(millis, isUtc: true).toLocal();
    }
    if (value is String && value.isNotEmpty) {
      return DateTime.tryParse(value);
    }
    return null;
  }
}

/// Encapsulates calls to the cloud API.
class CloudApi {
  /// Fetches the latest prediction series.
  static Future<Series> fetchLatest() async {
    final res = await _dio.get('/predict/latest');
    final data = _normalizeResponse(res);
    final series = _extractList(data, 'latest series', ['series', 'data', 'points']);
    return Series.fromJson(series);
  }

  /// Fetches a list of historic prediction items ordered by most recent.
  static Future<List<HistoryItem>> fetchHistoryIndex() async {
    final res = await _dio.get('/predict/history');
    final data = _normalizeResponse(res);
    final rawList = _extractList(data, 'history index', ['data', 'items', 'history']);
    final list = rawList.map((e) => HistoryItem.fromJson(e)).toList()
      ..sort((a, b) => b.date.compareTo(a.date));
    return list;
  }

  /// Fetches a historic prediction series by ID.
  static Future<Series> fetchHistoryById(String id) async {
    final res = await _dio.get('/predict/history/$id');
    final data = _normalizeResponse(res);
    final series = _extractList(data, 'history detail', ['series', 'data', 'points']);
    return Series.fromJson(series);
  }

  static dynamic _normalizeResponse(Response res) {
    final data = res.data;
    if (data is String) {
      final trimmed = data.trim();
      if (trimmed.isEmpty) return [];
      try {
        return jsonDecode(trimmed);
      } catch (_) {
        return data;
      }
    }
    return data;
  }

  static List<dynamic> _extractList(
    dynamic data,
    String context,
    List<String> candidateKeys,
  ) {
    if (data is List) {
      return data;
    }

    if (data is Map) {
      final map = data.map((key, value) => MapEntry(key.toString(), value));
      for (final key in candidateKeys) {
        final value = map[key];
        if (value is List) {
          return value;
        }
      }
    }

    throw StateError('Unexpected $context response shape: ${data.runtimeType}');
  }
}

/// Simple 3D vector implementation providing the handful of operations needed
/// for IMU orientation math without pulling an external dependency.
class Vector3 {
  double x;
  double y;
  double z;

  Vector3(this.x, this.y, this.z);

  Vector3 clone() => Vector3(x, y, z);

  double get lengthSquared => x * x + y * y + z * z;

  double get length2 => lengthSquared;

  double get length => math.sqrt(lengthSquared);

  void scale(double scalar) {
    x *= scalar;
    y *= scalar;
    z *= scalar;
  }

  void normalize() {
    final len = length;
    if (len < 1e-9) {
      x = 0;
