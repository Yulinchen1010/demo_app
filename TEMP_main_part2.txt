      y = 0;
      z = 0;
      return;
    }
    scale(1 / len);
  }

  double dot(Vector3 other) => x * other.x + y * other.y + z * other.z;

  Vector3 cross(Vector3 other) => Vector3(
        y * other.z - z * other.y,
        z * other.x - x * other.z,
        x * other.y - y * other.x,
      );
}

class Quaternion {
  double w;
  double x;
  double y;
  double z;

  Quaternion(this.w, this.x, this.y, this.z);

  factory Quaternion.identity() => Quaternion(1, 0, 0, 0);

  factory Quaternion.axisAngle(Vector3 axis, double angle) {
    final normalizedAxis = axis.clone();
    final axisLength = normalizedAxis.length;
    if (axisLength < 1e-9) {
      return Quaternion.identity();
    }
    normalizedAxis.scale(1 / axisLength);
    final half = angle / 2;
    final sinHalf = math.sin(half);
    final q = Quaternion(
      math.cos(half),
      normalizedAxis.x * sinHalf,
      normalizedAxis.y * sinHalf,
      normalizedAxis.z * sinHalf,
    );
    q.normalize();
    return q;
  }

  Quaternion copy() => Quaternion(w, x, y, z);

  void normalize() {
    final magnitude = math.sqrt(w * w + x * x + y * y + z * z);
    if (magnitude < 1e-9) {
      w = 1;
      x = y = z = 0;
      return;
    }
    final inv = 1 / magnitude;
    w *= inv;
    x *= inv;
    y *= inv;
    z *= inv;
  }

  void conjugate() {
    x = -x;
    y = -y;
    z = -z;
  }

  void multiply(Quaternion other) {
    final nw = w * other.w - x * other.x - y * other.y - z * other.z;
    final nx = w * other.x + x * other.w + y * other.z - z * other.y;
    final ny = w * other.y - x * other.z + y * other.w + z * other.x;
    final nz = w * other.z + x * other.y - y * other.x + z * other.w;
    w = nw;
    x = nx;
    y = ny;
    z = nz;
  }
}

/// Represents the raw IMU reading for a single sensor, including derived
/// orientation expressed as a quaternion relative to the gravity vector.
class ImuReading {
  final Vector3 accel;
  final Vector3 gyro;
  final Quaternion orientation;

  ImuReading._(this.accel, this.gyro, this.orientation);

  /// Builds an [ImuReading] from six sequential values:
  /// `[ax, ay, az, gx, gy, gz]`.
  factory ImuReading.fromValues(List<double> values) {
    final accel = Vector3(values[0], values[1], values[2]);
    final gyro = Vector3(values[3], values[4], values[5]);
    final orientation = _orientationFromAcceleration(accel);
    return ImuReading._(accel, gyro, orientation);
  }

  static Quaternion _orientationFromAcceleration(Vector3 accel) {
    final norm = accel.clone();
    final magnitude = norm.length;
    if (magnitude < 1e-6) {
      return Quaternion.identity();
    }
    norm.scale(1 / magnitude);
    final reference = Vector3(0, 0, -1);
    final dot = math.max(-1.0, math.min(1.0, reference.dot(norm)));
    final axis = reference.cross(norm);
    if (axis.length2 < 1e-12) {
      if (dot >= 0) {
        return Quaternion.identity();
      }
      // Opposite direction: rotate 180¬∞ around an arbitrary axis orthogonal to
      // gravity. X-axis keeps things simple.
      final fallback = Vector3(1, 0, 0);
      return Quaternion.axisAngle(fallback, math.pi);
    }
    axis.normalize();
    final angle = math.acos(dot);
    final q = Quaternion.axisAngle(axis, angle);
    q.normalize();
    return q;
  }
}

/// Container for the calculated joint angle of a sensor pair.
class JointAngleMeasurement {
  final String label;
  final double? vectorDegrees;
  final double? quaternionDegrees;

  const JointAngleMeasurement({
    required this.label,
    required this.vectorDegrees,
    required this.quaternionDegrees,
  });
}

/// Service that handles Bluetooth Low Energy (BLE) ingestion from an ESP32 device.
///
/// The service exposes separate [connect] and [listen] methods so you can
/// control when the connection is established and when data is consumed.
class BleIngestService {
  static const String kDeviceName = 'ESP32_EMG_IMU';

  final classic.FlutterBluetoothSerial _bluetooth =
      classic.FlutterBluetoothSerial.instance;
  classic.BluetoothConnection? _connection;
  StreamSubscription<Uint8List>? _subscription;

  /// Connects to the ESP32 over classic Bluetooth (SPP).
  Future<void> connect(String deviceName) async {
    await dispose();

    final granted = await _ensurePermissions();
    if (!granted) {
      throw Exception('?çÁ?/ÂÆö‰?Ê¨äÈ??™Â?Ë®?);
    }

    final isEnabled = await _bluetooth.isEnabled ?? false;
    if (!isEnabled) {
      final enabled = await _bluetooth.requestEnable();
      if (enabled != true) {
        throw Exception('Ë´ãÂ??ãÂ??çÁ??üËÉΩ');
      }
    }

    try {
      await _bluetooth.cancelDiscovery();
    } catch (_) {
      // Ignore discovery cancellation issues when Bluetooth is off.
    }
    final device = await _findDevice(deviceName);
    if (device == null) {
      throw Exception('?æ‰??∞ÁõÆÊ®ôË?ÁΩÆÔ?$deviceName');
    }

    try {
      _connection = await classic.BluetoothConnection.toAddress(device.address)
          .timeout(const Duration(seconds: 12));
    } on TimeoutException catch (_) {
      throw Exception('????æÊ?ÔºåË?Á¢∫Ë?Ë£ùÁΩÆÂ∑≤È?Ê©ü‰??ØË¢´?çÂ?');
    }
  }

  /// Begins listening for newline-delimited packets emitted by the ESP32.
  void listen(
    void Function(String line) onLine, {
    void Function(Object error)? onError,
    void Function()? onDone,
  }) {
    final conn = _connection;
    if (conn == null || !conn.isConnected) {
      throw StateError('Â∞öÊú™Âª∫Á??çÁ????');
    }

    final input = conn.input;
    if (input == null) {
      throw StateError('Ê≠§Ë?ÁΩÆÊ??âÂèØËÆÄ?ñÁ?Ë≥áÊ?‰∏≤Ê?');
    }

    final buffer = StringBuffer();
    _subscription = input.listen(
      (Uint8List data) {
        buffer.write(utf8.decode(data));
        while (true) {
          final current = buffer.toString();
          final idx = current.indexOf('\n');
          if (idx < 0) break;
          final line = current.substring(0, idx).trim();
          if (line.isNotEmpty) {
            onLine(line);
          }
          buffer
            ..clear()
            ..write(idx + 1 < current.length ? current.substring(idx + 1) : '');
        }
      },
      onError: onError,
      onDone: onDone,
      cancelOnError: false,
